[use]
plugin = basics
plugin = analytics

[XMLParse]
separator = /gexf/graph/attributes
separator = /gexf/graph/nodes/node
separator = /gexf/graph/edges/edge

# attributes
[swing]
test = get("attribute").isUndefined()
reverse = true

 # CrÃ©e une table de correspondance pour les attributs courants
[swing/replace]
path = attributes
value = get("attribute")?.reduce((acc, attr) => [...acc, {id: attr.id, title: attr.title}], [])

[swing]
test = get("attributes").isUndefined()
reverse = true
[swing/pluck]
path = attributes
[swing/aggregate]
[swing/assign]
path = value
value = get("value").flatten().flatten().sort((a,b) => a.id - b.id)
[swing/env]
path = attributes
value = get("value").map("title")
[swing/remove]
test = get("id").isEqual("attributes")

# edge
[swing]
test = get("source").isUndefined()
reverse = true

[swing/replace]
path = id
value = get('source')
path = targets.0.id
value = get('target')
path = targets.0.value
value = get('value')

# all paths
[replace]
path = id
value = get('id')
path = value
value = self().omit('id')

[aggregate]
path = id

[replace]
path = id
value = get('id')
path = value
value = get('value').thru(arrObj => _.mergeWith({}, ...arrObj, (objValue, srcValue) => _.isArray(objValue) ? objValue.concat(srcValue) : undefined ))

[assign]
path = value
value = get('value').omit('attvalues')
path = attributes
value = get('value.attvalues.attvalue', []).castArray().map(x=>({[env(`attributes.${x.for}`)]: x.value})).thru(x => _.merge({}, ...x))

[dump]
indent = true